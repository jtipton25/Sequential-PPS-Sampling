} else if(N < 2){
"N must be greater than 2"
} else if(is.integer(i) == FALSE){
"i must be an integer"
} else if(i < 0){
"i must be an integer between 1 and N"
} else if(i > N){
"i must be an integer between 1 and N"
} else if(N == 2){
if(i == 1){
(1 + 1 / 2) / 2
} else {
1
}
} else {
bias <- 1/2 * (factorial(N - 2) * sum(1:(N-1) / (2:N)) + 1 / 2) / (factorial(N)) * (N - i)
return(bias)
}
}
make.prob(4)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
if(i == 1){
(1 + 1 / 2) / 2
} else {
1
}
} else {
bias <- vector(length = N)
for(j in 1:(N-1))
bias[j] <- 1/2 * (factorial(N - 2) * sum(1:(N-1) / (2:N)) + 1 / 2) / (factorial(N)) * (N - j)
return(bias)
}
}
make.prob(4)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
if(i == 1){
(1 + 1 / 2) / 2
} else {
1
}
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- 1/2 * (factorial(N - 2) * sum(1:(N-1) / (2:N)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob(4)
make.prob.perm(4)
make.prob(4) + 1:4/4
N <- 2
make.prob(N) + 1:N/N
make.prob.perm(N)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- 1/2 * (factorial(N - 2) * sum(1:(N-1) / (2:N)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
N <- 2
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 3
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 4
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 5
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 6
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 4
make.prob(N) + 1:N/N
make.prob.perm(N)
N <- 4
make.prob(N)
make.prob.perm(N) - 1:N/N
apply(pi, 2, mean)
N <- 4
make.prob(N)
make.prob.perm(N) - 1:N/N
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- (factorial(N - 2) * sum(1:(N-1) / (2:N)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
N <- 4
make.prob(N)
make.prob.perm(N) - 1:N/N
N <- 45
N <- 5
make.prob(N)
make.prob.perm(N) - 1:N/N
N <- 6
make.prob(N)
make.prob.perm(N) - 1:N/N
.1190278 / .04833333
(1:(N-1)) / (2:N)
1:(N-1)
(1:(N-1)) / (2:N) * 1:(N-1)
bias[j] <- (factorial(N - 2) * sum(1:(N-1) / (2:N) * (1:N-1)) + 1 / 2) / (factorial(N)) * (N - j)
(factorial(N - 2) * sum(1:(N-1) / (2:N) * (1:N-1)) + 1 / 2) / (factorial(N)) * (N - j)
N
J
j
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- (factorial(N - 2) * sum(1:(N-1) / (2:N) * (1:N-1)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob(N)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- (factorial(N - 2) * sum(1:(N-1) / (2:N) * 1:(N-1)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
(1:(N-1)) / (2:N) * 1:(N-1)
## Works for N=1:4, breaks down for N=5 and 6
N <- 6
make.prob(N)
make.prob.perm(N) - 1:N/N
.3823611/.0483333
.3823611/.0483333333
(1:(N-1)) / (2:N) * 1:(N-1)
make.prob(N)
make.prob.perm(N) - 1:N/N
(1:(N-1)) / (2:N) * 1:(N-1)
9/4
16/5
25/4
25/3
25/5
25/6
factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1)
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1))
factorial(N)
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1)) / factorial(N)
make.prob.perm(N) - 1:N/N
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1)) / factorial(N)
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1) + factorial (N - 2)) / factorial(N)
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1) + factorial (N - 2)) / factorial(N) - (N-1)/N
vec <- 1:N
vec
vec <- 1:(N-1)
1:(N-1)
1:(N-1) / (2:N)
1:(N-1) * 1:(N-1) / (2:N)
sum(1:(N-1) * 1:(N-1) / (2:N))
factorial(N - 2) / factorial(N) *
sum(1:(N-1) * 1:(N-1) / (2:N))
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) * (sum(1:(N-1) / (2:N) * 1:(N-1)) + 1 / 2) / (factorial(N)) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob(N)
make.prob.perm(N) - 1:N/N
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) * (sum(1:(N-1) / (2:N) * 1:(N-1)) + 1 / 2) / (factorial(N)) #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob(N)
make.prob.perm(N) - 1:N/N
.398333333/.048333333
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1) + factorial (N - 2)) / factorial(N)
sum(1:(N-1) * 1:(N-1) / (2:N))
factorial(N - 2) / factorial(N) *sum(1:(N-1) * 1:(N-1) / (2:N))
bias[j] <- factorial(N - 2) / factorial(N) * (sum(1:(N-1) / (2:N) * 1:(N-1))) #* (N - j)
## 1615 = 5*17*19
15680/5027
3321
## 3321 = 3*3*3*3*41
5027/11
## 5027 = 11*457
15680/(2^6)/5
##15680 = 2*2*2*2*2*2*5*7*7
as.fractions(apply(pi, 2, mean))
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) / factorial(N) * (sum(1:(N-1) / (2:N) * 1:(N-1))) #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob(N)
make.prob.perm(N) - 1:N/N
factorial(N - 2) / factorial(N) *sum(1:(N-1) * 1:(N-1) / (2:N))
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) / factorial(N) * sum(1:(N-1) * 1:(N-1) / (2:N)) #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
N <- 4
make.prob(N)
make.prob.perm(N) - 1:N/N
N <- 3
make.prob(N)
make.prob.perm(N) - 1:N/N
.30555555/.13888889
as.fractions(sum(1:(N-1) * 1:(N-1) / (2:N)))
as.fractions(1:(N-1) * 1:(N-1) / (2:N))
N <- 6
factorial(N - 2) / factorial(N) * sum(1:(N-1) * 1:(N-1) / (2:N))
as.fractions(1:(N-1) * 1:(N-1) / (2:N))
factorial(N - 2)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N)) + 1 /2) #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
## Works for N=1:4, breaks down for N=5 and 6
N <- 6
make.prob(N)
make.prob.perm(N) - 1:N/N
make.prob(N)
make.prob.perm(N)
N <- 4
make.prob(N)
make.prob.perm(N)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
bias[j] <- factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
## Works for N=1:4, breaks down for N=5 and 6
N <- 4
make.prob(N)
make.prob.perm(N)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2) #* (N - j)
bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) #* (N - j)
}
bias[N] <- 0
return(bias)
}
}
N <- 4
make.prob(N)
make.prob.perm(N)
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2) #* (N - j)
bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
make.prob.perm(N) - 1:N / N
make.prob(N)
N <- 5
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 6
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 7
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 8
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 9
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 10
make.prob(N)
make.prob.perm(N) - 1:N / N
N <- 100
make.prob(N)
N <- 10000
## Works fast
make.prob(N)
warnings()
N <- 1000
make.prob(N)
?factorial
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2) #* (N - j)
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) * (N - j)
bias[j] <- (1 / (N * (N - 1)) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
N <- 1000
make.prob(N)
N <- 6
## Works fast
make.prob(N)
## Works slow
make.prob.perm(N) - 1:N / N
N <- 7
## Works fast
make.prob(N)
## Works slow
make.prob.perm(N) - 1:N / N
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1) + factorial (N - 2)) / factorial(N)
N <- 700000
## Works fast
make.prob(N)
N <- 7000
## Works fast
make.prob(N) + 1:N / N
N <- 7
## Works fast
make.prob(N) + 1:N / N
## Works slow
make.prob.perm(N) - 1:N / N
sum(factorial(N - 2) * (1:(N-1)) / (2:N) * 1:(N-1) + factorial (N - 2)) / factorial(N)
make.prob.perm(N)
make.prob(N) + 1:N / N
library(permute)
library(MASS)
##
## Exact Simulation of sampling design
##
ctrl <- how(maxperm = 10000000)
N <- 4
make.prob.perm <- function(N){
perm.mat <- rbind(1:N, allPerms(N, control = ctrl))
pi <- matrix(nrow = dim(perm.mat)[1], ncol = dim(perm.mat)[2])
for(i in 1:dim(perm.mat)[1]){
for(k in 1:dim(perm.mat)[2]){
x <- perm.mat[i, 1:k]
fn <- ecdf(x)
pi[i, perm.mat[i,k]] <- fn(x)[k]
}
#	pi[i,] <- pi[i, ][perm.mat[i,]]
}
apply(pi, 2, mean)
}
##
## Analytic Formula for sampling weights
##
##
## \hat{\pi}_i - \pi_i  = (\frac{(N - 2)!} {N!} * \sum_{k = 1}^{N - 1} k \frac{k} {k + 1} + \frac{1} {2} - \frac{N - 1} {N}) * (N - i)
##
make.prob <- function(N){
if(floor(N) < N){
"N must be an integer"
} else if(N < 2){
"N must be greater than 2"
} else if(N == 2){
bias <- c(1 / 4, 0)
} else {
bias <- vector(length = N)
for(j in 1:(N-1)){
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2) #* (N - j)
#bias[j] <- (factorial(N - 2) / factorial(N) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) * (N - j)
bias[j] <- (1 / (N * (N - 1)) * (sum(1:(N-1) * 1:(N-1) / (2:N))) + 1 /2 - (N - 1) / N) * (N - j)
}
bias[N] <- 0
return(bias)
}
}
## Works for N=1:8 relatively quick, slows down dramatically for N > 8
N <- 7
## Works fast
make.prob(N) + 1:N / N
## Works slow
make.prob.perm(N)
